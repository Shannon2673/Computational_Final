{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Data Generation\n",
    "\n",
    "Shannon Gallagher Computational Physics Final Spring 2020 (PHY325). \n",
    "\n",
    "The cells below contain the code I used for data generation for my neural network. From the initialization of the percolation lattice to saving the different data.\n",
    "\n",
    "As part of my project to transform a 2d cluster grid into a neural network to model percolation, this jupyter notebook focuses on the construction of the 2d grid. \n",
    "\n",
    "So to create this grid one must understand two components:\n",
    "1. Computational: How to create and tune a 2d cluster grid\n",
    "2. Physical: What is the physical basis of this percolation model\n",
    "\n",
    "\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### References\n",
    "\n",
    "I am basing my 2d grid model off of the Ising model in Giordano's Computational Physics as well as this example from the scipython website: https://scipython.com/blog/the-forest-fire-model/.\n",
    "\n",
    "\n",
    "Giordano N. 1997. \"Computational Physics.\" Upper Sadie River, NJ: Pretence-Hall inc. p. 315-328\n",
    "\n",
    "Forest Fire Model [Online]. The Forest-fire model. https://scipython.com/blog/the-forest-fire-model/ [10 May 2020].\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "metadata": {},
   "outputs": [],
   "source": [
    "#standard import cell\n",
    "\n",
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "from matplotlib import animation\n",
    "from matplotlib import colors\n",
    "import random"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Animation\n",
    "The cell below is a space which I used to experiment with the water percolation model. The cell below creates an animation after being run. As of the time this is written I have not yet been able to find a method to save the animations with my laptop due to software issues, however there is a commented out command to save with ffmpeg for anyone who has it installed and opertaional. \n",
    "\n",
    "The inital lattice for this project was 100 x 100, which meant that there were 10000 cells in the lattice. This was very computationally taxing, for reasons that will become clear upon neural network implementation. So I reduced the size to 50x50 which is 1/4 the number of cells. The smaller lattice exhibited the same percolation behavior (threshold/ qualitative motion patterns) so I moved forward with the 50 x 50 lattice. \n",
    "\n",
    "For those who have greated compuational power, or more patience, the 100 x 100 data is saved in this folder."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "application/javascript": [
       "/* Put everything inside the global mpl namespace */\n",
       "window.mpl = {};\n",
       "\n",
       "\n",
       "mpl.get_websocket_type = function() {\n",
       "    if (typeof(WebSocket) !== 'undefined') {\n",
       "        return WebSocket;\n",
       "    } else if (typeof(MozWebSocket) !== 'undefined') {\n",
       "        return MozWebSocket;\n",
       "    } else {\n",
       "        alert('Your browser does not have WebSocket support. ' +\n",
       "              'Please try Chrome, Safari or Firefox â‰¥ 6. ' +\n",
       "              'Firefox 4 and 5 are also supported but you ' +\n",
       "              'have to enable WebSockets in about:config.');\n",
       "    };\n",
       "}\n",
       "\n",
       "mpl.figure = function(figure_id, websocket, ondownload, parent_element) {\n",
       "    this.id = figure_id;\n",
       "\n",
       "    this.ws = websocket;\n",
       "\n",
       "    this.supports_binary = (this.ws.binaryType != undefined);\n",
       "\n",
       "    if (!this.supports_binary) {\n",
       "        var warnings = document.getElementById(\"mpl-warnings\");\n",
       "        if (warnings) {\n",
       "            warnings.style.display = 'block';\n",
       "            warnings.textContent = (\n",
       "                \"This browser does not support binary websocket messages. \" +\n",
       "                    \"Performance may be slow.\");\n",
       "        }\n",
       "    }\n",
       "\n",
       "    this.imageObj = new Image();\n",
       "\n",
       "    this.context = undefined;\n",
       "    this.message = undefined;\n",
       "    this.canvas = undefined;\n",
       "    this.rubberband_canvas = undefined;\n",
       "    this.rubberband_context = undefined;\n",
       "    this.format_dropdown = undefined;\n",
       "\n",
       "    this.image_mode = 'full';\n",
       "\n",
       "    this.root = $('<div/>');\n",
       "    this._root_extra_style(this.root)\n",
       "    this.root.attr('style', 'display: inline-block');\n",
       "\n",
       "    $(parent_element).append(this.root);\n",
       "\n",
       "    this._init_header(this);\n",
       "    this._init_canvas(this);\n",
       "    this._init_toolbar(this);\n",
       "\n",
       "    var fig = this;\n",
       "\n",
       "    this.waiting = false;\n",
       "\n",
       "    this.ws.onopen =  function () {\n",
       "            fig.send_message(\"supports_binary\", {value: fig.supports_binary});\n",
       "            fig.send_message(\"send_image_mode\", {});\n",
       "            if (mpl.ratio != 1) {\n",
       "                fig.send_message(\"set_dpi_ratio\", {'dpi_ratio': mpl.ratio});\n",
       "            }\n",
       "            fig.send_message(\"refresh\", {});\n",
       "        }\n",
       "\n",
       "    this.imageObj.onload = function() {\n",
       "            if (fig.image_mode == 'full') {\n",
       "                // Full images could contain transparency (where diff images\n",
       "                // almost always do), so we need to clear the canvas so that\n",
       "                // there is no ghosting.\n",
       "                fig.context.clearRect(0, 0, fig.canvas.width, fig.canvas.height);\n",
       "            }\n",
       "            fig.context.drawImage(fig.imageObj, 0, 0);\n",
       "        };\n",
       "\n",
       "    this.imageObj.onunload = function() {\n",
       "        fig.ws.close();\n",
       "    }\n",
       "\n",
       "    this.ws.onmessage = this._make_on_message_function(this);\n",
       "\n",
       "    this.ondownload = ondownload;\n",
       "}\n",
       "\n",
       "mpl.figure.prototype._init_header = function() {\n",
       "    var titlebar = $(\n",
       "        '<div class=\"ui-dialog-titlebar ui-widget-header ui-corner-all ' +\n",
       "        'ui-helper-clearfix\"/>');\n",
       "    var titletext = $(\n",
       "        '<div class=\"ui-dialog-title\" style=\"width: 100%; ' +\n",
       "        'text-align: center; padding: 3px;\"/>');\n",
       "    titlebar.append(titletext)\n",
       "    this.root.append(titlebar);\n",
       "    this.header = titletext[0];\n",
       "}\n",
       "\n",
       "\n",
       "\n",
       "mpl.figure.prototype._canvas_extra_style = function(canvas_div) {\n",
       "\n",
       "}\n",
       "\n",
       "\n",
       "mpl.figure.prototype._root_extra_style = function(canvas_div) {\n",
       "\n",
       "}\n",
       "\n",
       "mpl.figure.prototype._init_canvas = function() {\n",
       "    var fig = this;\n",
       "\n",
       "    var canvas_div = $('<div/>');\n",
       "\n",
       "    canvas_div.attr('style', 'position: relative; clear: both; outline: 0');\n",
       "\n",
       "    function canvas_keyboard_event(event) {\n",
       "        return fig.key_event(event, event['data']);\n",
       "    }\n",
       "\n",
       "    canvas_div.keydown('key_press', canvas_keyboard_event);\n",
       "    canvas_div.keyup('key_release', canvas_keyboard_event);\n",
       "    this.canvas_div = canvas_div\n",
       "    this._canvas_extra_style(canvas_div)\n",
       "    this.root.append(canvas_div);\n",
       "\n",
       "    var canvas = $('<canvas/>');\n",
       "    canvas.addClass('mpl-canvas');\n",
       "    canvas.attr('style', \"left: 0; top: 0; z-index: 0; outline: 0\")\n",
       "\n",
       "    this.canvas = canvas[0];\n",
       "    this.context = canvas[0].getContext(\"2d\");\n",
       "\n",
       "    var backingStore = this.context.backingStorePixelRatio ||\n",
       "\tthis.context.webkitBackingStorePixelRatio ||\n",
       "\tthis.context.mozBackingStorePixelRatio ||\n",
       "\tthis.context.msBackingStorePixelRatio ||\n",
       "\tthis.context.oBackingStorePixelRatio ||\n",
       "\tthis.context.backingStorePixelRatio || 1;\n",
       "\n",
       "    mpl.ratio = (window.devicePixelRatio || 1) / backingStore;\n",
       "\n",
       "    var rubberband = $('<canvas/>');\n",
       "    rubberband.attr('style', \"position: absolute; left: 0; top: 0; z-index: 1;\")\n",
       "\n",
       "    var pass_mouse_events = true;\n",
       "\n",
       "    canvas_div.resizable({\n",
       "        start: function(event, ui) {\n",
       "            pass_mouse_events = false;\n",
       "        },\n",
       "        resize: function(event, ui) {\n",
       "            fig.request_resize(ui.size.width, ui.size.height);\n",
       "        },\n",
       "        stop: function(event, ui) {\n",
       "            pass_mouse_events = true;\n",
       "            fig.request_resize(ui.size.width, ui.size.height);\n",
       "        },\n",
       "    });\n",
       "\n",
       "    function mouse_event_fn(event) {\n",
       "        if (pass_mouse_events)\n",
       "            return fig.mouse_event(event, event['data']);\n",
       "    }\n",
       "\n",
       "    rubberband.mousedown('button_press', mouse_event_fn);\n",
       "    rubberband.mouseup('button_release', mouse_event_fn);\n",
       "    // Throttle sequential mouse events to 1 every 20ms.\n",
       "    rubberband.mousemove('motion_notify', mouse_event_fn);\n",
       "\n",
       "    rubberband.mouseenter('figure_enter', mouse_event_fn);\n",
       "    rubberband.mouseleave('figure_leave', mouse_event_fn);\n",
       "\n",
       "    canvas_div.on(\"wheel\", function (event) {\n",
       "        event = event.originalEvent;\n",
       "        event['data'] = 'scroll'\n",
       "        if (event.deltaY < 0) {\n",
       "            event.step = 1;\n",
       "        } else {\n",
       "            event.step = -1;\n",
       "        }\n",
       "        mouse_event_fn(event);\n",
       "    });\n",
       "\n",
       "    canvas_div.append(canvas);\n",
       "    canvas_div.append(rubberband);\n",
       "\n",
       "    this.rubberband = rubberband;\n",
       "    this.rubberband_canvas = rubberband[0];\n",
       "    this.rubberband_context = rubberband[0].getContext(\"2d\");\n",
       "    this.rubberband_context.strokeStyle = \"#000000\";\n",
       "\n",
       "    this._resize_canvas = function(width, height) {\n",
       "        // Keep the size of the canvas, canvas container, and rubber band\n",
       "        // canvas in synch.\n",
       "        canvas_div.css('width', width)\n",
       "        canvas_div.css('height', height)\n",
       "\n",
       "        canvas.attr('width', width * mpl.ratio);\n",
       "        canvas.attr('height', height * mpl.ratio);\n",
       "        canvas.attr('style', 'width: ' + width + 'px; height: ' + height + 'px;');\n",
       "\n",
       "        rubberband.attr('width', width);\n",
       "        rubberband.attr('height', height);\n",
       "    }\n",
       "\n",
       "    // Set the figure to an initial 600x600px, this will subsequently be updated\n",
       "    // upon first draw.\n",
       "    this._resize_canvas(600, 600);\n",
       "\n",
       "    // Disable right mouse context menu.\n",
       "    $(this.rubberband_canvas).bind(\"contextmenu\",function(e){\n",
       "        return false;\n",
       "    });\n",
       "\n",
       "    function set_focus () {\n",
       "        canvas.focus();\n",
       "        canvas_div.focus();\n",
       "    }\n",
       "\n",
       "    window.setTimeout(set_focus, 100);\n",
       "}\n",
       "\n",
       "mpl.figure.prototype._init_toolbar = function() {\n",
       "    var fig = this;\n",
       "\n",
       "    var nav_element = $('<div/>');\n",
       "    nav_element.attr('style', 'width: 100%');\n",
       "    this.root.append(nav_element);\n",
       "\n",
       "    // Define a callback function for later on.\n",
       "    function toolbar_event(event) {\n",
       "        return fig.toolbar_button_onclick(event['data']);\n",
       "    }\n",
       "    function toolbar_mouse_event(event) {\n",
       "        return fig.toolbar_button_onmouseover(event['data']);\n",
       "    }\n",
       "\n",
       "    for(var toolbar_ind in mpl.toolbar_items) {\n",
       "        var name = mpl.toolbar_items[toolbar_ind][0];\n",
       "        var tooltip = mpl.toolbar_items[toolbar_ind][1];\n",
       "        var image = mpl.toolbar_items[toolbar_ind][2];\n",
       "        var method_name = mpl.toolbar_items[toolbar_ind][3];\n",
       "\n",
       "        if (!name) {\n",
       "            // put a spacer in here.\n",
       "            continue;\n",
       "        }\n",
       "        var button = $('<button/>');\n",
       "        button.addClass('ui-button ui-widget ui-state-default ui-corner-all ' +\n",
       "                        'ui-button-icon-only');\n",
       "        button.attr('role', 'button');\n",
       "        button.attr('aria-disabled', 'false');\n",
       "        button.click(method_name, toolbar_event);\n",
       "        button.mouseover(tooltip, toolbar_mouse_event);\n",
       "\n",
       "        var icon_img = $('<span/>');\n",
       "        icon_img.addClass('ui-button-icon-primary ui-icon');\n",
       "        icon_img.addClass(image);\n",
       "        icon_img.addClass('ui-corner-all');\n",
       "\n",
       "        var tooltip_span = $('<span/>');\n",
       "        tooltip_span.addClass('ui-button-text');\n",
       "        tooltip_span.html(tooltip);\n",
       "\n",
       "        button.append(icon_img);\n",
       "        button.append(tooltip_span);\n",
       "\n",
       "        nav_element.append(button);\n",
       "    }\n",
       "\n",
       "    var fmt_picker_span = $('<span/>');\n",
       "\n",
       "    var fmt_picker = $('<select/>');\n",
       "    fmt_picker.addClass('mpl-toolbar-option ui-widget ui-widget-content');\n",
       "    fmt_picker_span.append(fmt_picker);\n",
       "    nav_element.append(fmt_picker_span);\n",
       "    this.format_dropdown = fmt_picker[0];\n",
       "\n",
       "    for (var ind in mpl.extensions) {\n",
       "        var fmt = mpl.extensions[ind];\n",
       "        var option = $(\n",
       "            '<option/>', {selected: fmt === mpl.default_extension}).html(fmt);\n",
       "        fmt_picker.append(option);\n",
       "    }\n",
       "\n",
       "    // Add hover states to the ui-buttons\n",
       "    $( \".ui-button\" ).hover(\n",
       "        function() { $(this).addClass(\"ui-state-hover\");},\n",
       "        function() { $(this).removeClass(\"ui-state-hover\");}\n",
       "    );\n",
       "\n",
       "    var status_bar = $('<span class=\"mpl-message\"/>');\n",
       "    nav_element.append(status_bar);\n",
       "    this.message = status_bar[0];\n",
       "}\n",
       "\n",
       "mpl.figure.prototype.request_resize = function(x_pixels, y_pixels) {\n",
       "    // Request matplotlib to resize the figure. Matplotlib will then trigger a resize in the client,\n",
       "    // which will in turn request a refresh of the image.\n",
       "    this.send_message('resize', {'width': x_pixels, 'height': y_pixels});\n",
       "}\n",
       "\n",
       "mpl.figure.prototype.send_message = function(type, properties) {\n",
       "    properties['type'] = type;\n",
       "    properties['figure_id'] = this.id;\n",
       "    this.ws.send(JSON.stringify(properties));\n",
       "}\n",
       "\n",
       "mpl.figure.prototype.send_draw_message = function() {\n",
       "    if (!this.waiting) {\n",
       "        this.waiting = true;\n",
       "        this.ws.send(JSON.stringify({type: \"draw\", figure_id: this.id}));\n",
       "    }\n",
       "}\n",
       "\n",
       "\n",
       "mpl.figure.prototype.handle_save = function(fig, msg) {\n",
       "    var format_dropdown = fig.format_dropdown;\n",
       "    var format = format_dropdown.options[format_dropdown.selectedIndex].value;\n",
       "    fig.ondownload(fig, format);\n",
       "}\n",
       "\n",
       "\n",
       "mpl.figure.prototype.handle_resize = function(fig, msg) {\n",
       "    var size = msg['size'];\n",
       "    if (size[0] != fig.canvas.width || size[1] != fig.canvas.height) {\n",
       "        fig._resize_canvas(size[0], size[1]);\n",
       "        fig.send_message(\"refresh\", {});\n",
       "    };\n",
       "}\n",
       "\n",
       "mpl.figure.prototype.handle_rubberband = function(fig, msg) {\n",
       "    var x0 = msg['x0'] / mpl.ratio;\n",
       "    var y0 = (fig.canvas.height - msg['y0']) / mpl.ratio;\n",
       "    var x1 = msg['x1'] / mpl.ratio;\n",
       "    var y1 = (fig.canvas.height - msg['y1']) / mpl.ratio;\n",
       "    x0 = Math.floor(x0) + 0.5;\n",
       "    y0 = Math.floor(y0) + 0.5;\n",
       "    x1 = Math.floor(x1) + 0.5;\n",
       "    y1 = Math.floor(y1) + 0.5;\n",
       "    var min_x = Math.min(x0, x1);\n",
       "    var min_y = Math.min(y0, y1);\n",
       "    var width = Math.abs(x1 - x0);\n",
       "    var height = Math.abs(y1 - y0);\n",
       "\n",
       "    fig.rubberband_context.clearRect(\n",
       "        0, 0, fig.canvas.width / mpl.ratio, fig.canvas.height / mpl.ratio);\n",
       "\n",
       "    fig.rubberband_context.strokeRect(min_x, min_y, width, height);\n",
       "}\n",
       "\n",
       "mpl.figure.prototype.handle_figure_label = function(fig, msg) {\n",
       "    // Updates the figure title.\n",
       "    fig.header.textContent = msg['label'];\n",
       "}\n",
       "\n",
       "mpl.figure.prototype.handle_cursor = function(fig, msg) {\n",
       "    var cursor = msg['cursor'];\n",
       "    switch(cursor)\n",
       "    {\n",
       "    case 0:\n",
       "        cursor = 'pointer';\n",
       "        break;\n",
       "    case 1:\n",
       "        cursor = 'default';\n",
       "        break;\n",
       "    case 2:\n",
       "        cursor = 'crosshair';\n",
       "        break;\n",
       "    case 3:\n",
       "        cursor = 'move';\n",
       "        break;\n",
       "    }\n",
       "    fig.rubberband_canvas.style.cursor = cursor;\n",
       "}\n",
       "\n",
       "mpl.figure.prototype.handle_message = function(fig, msg) {\n",
       "    fig.message.textContent = msg['message'];\n",
       "}\n",
       "\n",
       "mpl.figure.prototype.handle_draw = function(fig, msg) {\n",
       "    // Request the server to send over a new figure.\n",
       "    fig.send_draw_message();\n",
       "}\n",
       "\n",
       "mpl.figure.prototype.handle_image_mode = function(fig, msg) {\n",
       "    fig.image_mode = msg['mode'];\n",
       "}\n",
       "\n",
       "mpl.figure.prototype.updated_canvas_event = function() {\n",
       "    // Called whenever the canvas gets updated.\n",
       "    this.send_message(\"ack\", {});\n",
       "}\n",
       "\n",
       "// A function to construct a web socket function for onmessage handling.\n",
       "// Called in the figure constructor.\n",
       "mpl.figure.prototype._make_on_message_function = function(fig) {\n",
       "    return function socket_on_message(evt) {\n",
       "        if (evt.data instanceof Blob) {\n",
       "            /* FIXME: We get \"Resource interpreted as Image but\n",
       "             * transferred with MIME type text/plain:\" errors on\n",
       "             * Chrome.  But how to set the MIME type?  It doesn't seem\n",
       "             * to be part of the websocket stream */\n",
       "            evt.data.type = \"image/png\";\n",
       "\n",
       "            /* Free the memory for the previous frames */\n",
       "            if (fig.imageObj.src) {\n",
       "                (window.URL || window.webkitURL).revokeObjectURL(\n",
       "                    fig.imageObj.src);\n",
       "            }\n",
       "\n",
       "            fig.imageObj.src = (window.URL || window.webkitURL).createObjectURL(\n",
       "                evt.data);\n",
       "            fig.updated_canvas_event();\n",
       "            fig.waiting = false;\n",
       "            return;\n",
       "        }\n",
       "        else if (typeof evt.data === 'string' && evt.data.slice(0, 21) == \"data:image/png;base64\") {\n",
       "            fig.imageObj.src = evt.data;\n",
       "            fig.updated_canvas_event();\n",
       "            fig.waiting = false;\n",
       "            return;\n",
       "        }\n",
       "\n",
       "        var msg = JSON.parse(evt.data);\n",
       "        var msg_type = msg['type'];\n",
       "\n",
       "        // Call the  \"handle_{type}\" callback, which takes\n",
       "        // the figure and JSON message as its only arguments.\n",
       "        try {\n",
       "            var callback = fig[\"handle_\" + msg_type];\n",
       "        } catch (e) {\n",
       "            console.log(\"No handler for the '\" + msg_type + \"' message type: \", msg);\n",
       "            return;\n",
       "        }\n",
       "\n",
       "        if (callback) {\n",
       "            try {\n",
       "                // console.log(\"Handling '\" + msg_type + \"' message: \", msg);\n",
       "                callback(fig, msg);\n",
       "            } catch (e) {\n",
       "                console.log(\"Exception inside the 'handler_\" + msg_type + \"' callback:\", e, e.stack, msg);\n",
       "            }\n",
       "        }\n",
       "    };\n",
       "}\n",
       "\n",
       "// from http://stackoverflow.com/questions/1114465/getting-mouse-location-in-canvas\n",
       "mpl.findpos = function(e) {\n",
       "    //this section is from http://www.quirksmode.org/js/events_properties.html\n",
       "    var targ;\n",
       "    if (!e)\n",
       "        e = window.event;\n",
       "    if (e.target)\n",
       "        targ = e.target;\n",
       "    else if (e.srcElement)\n",
       "        targ = e.srcElement;\n",
       "    if (targ.nodeType == 3) // defeat Safari bug\n",
       "        targ = targ.parentNode;\n",
       "\n",
       "    // jQuery normalizes the pageX and pageY\n",
       "    // pageX,Y are the mouse positions relative to the document\n",
       "    // offset() returns the position of the element relative to the document\n",
       "    var x = e.pageX - $(targ).offset().left;\n",
       "    var y = e.pageY - $(targ).offset().top;\n",
       "\n",
       "    return {\"x\": x, \"y\": y};\n",
       "};\n",
       "\n",
       "/*\n",
       " * return a copy of an object with only non-object keys\n",
       " * we need this to avoid circular references\n",
       " * http://stackoverflow.com/a/24161582/3208463\n",
       " */\n",
       "function simpleKeys (original) {\n",
       "  return Object.keys(original).reduce(function (obj, key) {\n",
       "    if (typeof original[key] !== 'object')\n",
       "        obj[key] = original[key]\n",
       "    return obj;\n",
       "  }, {});\n",
       "}\n",
       "\n",
       "mpl.figure.prototype.mouse_event = function(event, name) {\n",
       "    var canvas_pos = mpl.findpos(event)\n",
       "\n",
       "    if (name === 'button_press')\n",
       "    {\n",
       "        this.canvas.focus();\n",
       "        this.canvas_div.focus();\n",
       "    }\n",
       "\n",
       "    var x = canvas_pos.x * mpl.ratio;\n",
       "    var y = canvas_pos.y * mpl.ratio;\n",
       "\n",
       "    this.send_message(name, {x: x, y: y, button: event.button,\n",
       "                             step: event.step,\n",
       "                             guiEvent: simpleKeys(event)});\n",
       "\n",
       "    /* This prevents the web browser from automatically changing to\n",
       "     * the text insertion cursor when the button is pressed.  We want\n",
       "     * to control all of the cursor setting manually through the\n",
       "     * 'cursor' event from matplotlib */\n",
       "    event.preventDefault();\n",
       "    return false;\n",
       "}\n",
       "\n",
       "mpl.figure.prototype._key_event_extra = function(event, name) {\n",
       "    // Handle any extra behaviour associated with a key event\n",
       "}\n",
       "\n",
       "mpl.figure.prototype.key_event = function(event, name) {\n",
       "\n",
       "    // Prevent repeat events\n",
       "    if (name == 'key_press')\n",
       "    {\n",
       "        if (event.which === this._key)\n",
       "            return;\n",
       "        else\n",
       "            this._key = event.which;\n",
       "    }\n",
       "    if (name == 'key_release')\n",
       "        this._key = null;\n",
       "\n",
       "    var value = '';\n",
       "    if (event.ctrlKey && event.which != 17)\n",
       "        value += \"ctrl+\";\n",
       "    if (event.altKey && event.which != 18)\n",
       "        value += \"alt+\";\n",
       "    if (event.shiftKey && event.which != 16)\n",
       "        value += \"shift+\";\n",
       "\n",
       "    value += 'k';\n",
       "    value += event.which.toString();\n",
       "\n",
       "    this._key_event_extra(event, name);\n",
       "\n",
       "    this.send_message(name, {key: value,\n",
       "                             guiEvent: simpleKeys(event)});\n",
       "    return false;\n",
       "}\n",
       "\n",
       "mpl.figure.prototype.toolbar_button_onclick = function(name) {\n",
       "    if (name == 'download') {\n",
       "        this.handle_save(this, null);\n",
       "    } else {\n",
       "        this.send_message(\"toolbar_button\", {name: name});\n",
       "    }\n",
       "};\n",
       "\n",
       "mpl.figure.prototype.toolbar_button_onmouseover = function(tooltip) {\n",
       "    this.message.textContent = tooltip;\n",
       "};\n",
       "mpl.toolbar_items = [[\"Home\", \"Reset original view\", \"fa fa-home icon-home\", \"home\"], [\"Back\", \"Back to previous view\", \"fa fa-arrow-left icon-arrow-left\", \"back\"], [\"Forward\", \"Forward to next view\", \"fa fa-arrow-right icon-arrow-right\", \"forward\"], [\"\", \"\", \"\", \"\"], [\"Pan\", \"Pan axes with left mouse, zoom with right\", \"fa fa-arrows icon-move\", \"pan\"], [\"Zoom\", \"Zoom to rectangle\", \"fa fa-square-o icon-check-empty\", \"zoom\"], [\"\", \"\", \"\", \"\"], [\"Download\", \"Download plot\", \"fa fa-floppy-o icon-save\", \"download\"]];\n",
       "\n",
       "mpl.extensions = [\"eps\", \"jpeg\", \"pdf\", \"png\", \"ps\", \"raw\", \"svg\", \"tif\"];\n",
       "\n",
       "mpl.default_extension = \"png\";var comm_websocket_adapter = function(comm) {\n",
       "    // Create a \"websocket\"-like object which calls the given IPython comm\n",
       "    // object with the appropriate methods. Currently this is a non binary\n",
       "    // socket, so there is still some room for performance tuning.\n",
       "    var ws = {};\n",
       "\n",
       "    ws.close = function() {\n",
       "        comm.close()\n",
       "    };\n",
       "    ws.send = function(m) {\n",
       "        //console.log('sending', m);\n",
       "        comm.send(m);\n",
       "    };\n",
       "    // Register the callback with on_msg.\n",
       "    comm.on_msg(function(msg) {\n",
       "        //console.log('receiving', msg['content']['data'], msg);\n",
       "        // Pass the mpl event to the overridden (by mpl) onmessage function.\n",
       "        ws.onmessage(msg['content']['data'])\n",
       "    });\n",
       "    return ws;\n",
       "}\n",
       "\n",
       "mpl.mpl_figure_comm = function(comm, msg) {\n",
       "    // This is the function which gets called when the mpl process\n",
       "    // starts-up an IPython Comm through the \"matplotlib\" channel.\n",
       "\n",
       "    var id = msg.content.data.id;\n",
       "    // Get hold of the div created by the display call when the Comm\n",
       "    // socket was opened in Python.\n",
       "    var element = $(\"#\" + id);\n",
       "    var ws_proxy = comm_websocket_adapter(comm)\n",
       "\n",
       "    function ondownload(figure, format) {\n",
       "        window.open(figure.imageObj.src);\n",
       "    }\n",
       "\n",
       "    var fig = new mpl.figure(id, ws_proxy,\n",
       "                           ondownload,\n",
       "                           element.get(0));\n",
       "\n",
       "    // Call onopen now - mpl needs it, as it is assuming we've passed it a real\n",
       "    // web socket which is closed, not our websocket->open comm proxy.\n",
       "    ws_proxy.onopen();\n",
       "\n",
       "    fig.parent_element = element.get(0);\n",
       "    fig.cell_info = mpl.find_output_cell(\"<div id='\" + id + \"'></div>\");\n",
       "    if (!fig.cell_info) {\n",
       "        console.error(\"Failed to find cell for figure\", id, fig);\n",
       "        return;\n",
       "    }\n",
       "\n",
       "    var output_index = fig.cell_info[2]\n",
       "    var cell = fig.cell_info[0];\n",
       "\n",
       "};\n",
       "\n",
       "mpl.figure.prototype.handle_close = function(fig, msg) {\n",
       "    var width = fig.canvas.width/mpl.ratio\n",
       "    fig.root.unbind('remove')\n",
       "\n",
       "    // Update the output cell to use the data from the current canvas.\n",
       "    fig.push_to_output();\n",
       "    var dataURL = fig.canvas.toDataURL();\n",
       "    // Re-enable the keyboard manager in IPython - without this line, in FF,\n",
       "    // the notebook keyboard shortcuts fail.\n",
       "    IPython.keyboard_manager.enable()\n",
       "    $(fig.parent_element).html('<img src=\"' + dataURL + '\" width=\"' + width + '\">');\n",
       "    fig.close_ws(fig, msg);\n",
       "}\n",
       "\n",
       "mpl.figure.prototype.close_ws = function(fig, msg){\n",
       "    fig.send_message('closing', msg);\n",
       "    // fig.ws.close()\n",
       "}\n",
       "\n",
       "mpl.figure.prototype.push_to_output = function(remove_interactive) {\n",
       "    // Turn the data on the canvas into data in the output cell.\n",
       "    var width = this.canvas.width/mpl.ratio\n",
       "    var dataURL = this.canvas.toDataURL();\n",
       "    this.cell_info[1]['text/html'] = '<img src=\"' + dataURL + '\" width=\"' + width + '\">';\n",
       "}\n",
       "\n",
       "mpl.figure.prototype.updated_canvas_event = function() {\n",
       "    // Tell IPython that the notebook contents must change.\n",
       "    IPython.notebook.set_dirty(true);\n",
       "    this.send_message(\"ack\", {});\n",
       "    var fig = this;\n",
       "    // Wait a second, then push the new image to the DOM so\n",
       "    // that it is saved nicely (might be nice to debounce this).\n",
       "    setTimeout(function () { fig.push_to_output() }, 1000);\n",
       "}\n",
       "\n",
       "mpl.figure.prototype._init_toolbar = function() {\n",
       "    var fig = this;\n",
       "\n",
       "    var nav_element = $('<div/>');\n",
       "    nav_element.attr('style', 'width: 100%');\n",
       "    this.root.append(nav_element);\n",
       "\n",
       "    // Define a callback function for later on.\n",
       "    function toolbar_event(event) {\n",
       "        return fig.toolbar_button_onclick(event['data']);\n",
       "    }\n",
       "    function toolbar_mouse_event(event) {\n",
       "        return fig.toolbar_button_onmouseover(event['data']);\n",
       "    }\n",
       "\n",
       "    for(var toolbar_ind in mpl.toolbar_items){\n",
       "        var name = mpl.toolbar_items[toolbar_ind][0];\n",
       "        var tooltip = mpl.toolbar_items[toolbar_ind][1];\n",
       "        var image = mpl.toolbar_items[toolbar_ind][2];\n",
       "        var method_name = mpl.toolbar_items[toolbar_ind][3];\n",
       "\n",
       "        if (!name) { continue; };\n",
       "\n",
       "        var button = $('<button class=\"btn btn-default\" href=\"#\" title=\"' + name + '\"><i class=\"fa ' + image + ' fa-lg\"></i></button>');\n",
       "        button.click(method_name, toolbar_event);\n",
       "        button.mouseover(tooltip, toolbar_mouse_event);\n",
       "        nav_element.append(button);\n",
       "    }\n",
       "\n",
       "    // Add the status bar.\n",
       "    var status_bar = $('<span class=\"mpl-message\" style=\"text-align:right; float: right;\"/>');\n",
       "    nav_element.append(status_bar);\n",
       "    this.message = status_bar[0];\n",
       "\n",
       "    // Add the close button to the window.\n",
       "    var buttongrp = $('<div class=\"btn-group inline pull-right\"></div>');\n",
       "    var button = $('<button class=\"btn btn-mini btn-primary\" href=\"#\" title=\"Stop Interaction\"><i class=\"fa fa-power-off icon-remove icon-large\"></i></button>');\n",
       "    button.click(function (evt) { fig.handle_close(fig, {}); } );\n",
       "    button.mouseover('Stop Interaction', toolbar_mouse_event);\n",
       "    buttongrp.append(button);\n",
       "    var titlebar = this.root.find($('.ui-dialog-titlebar'));\n",
       "    titlebar.prepend(buttongrp);\n",
       "}\n",
       "\n",
       "mpl.figure.prototype._root_extra_style = function(el){\n",
       "    var fig = this\n",
       "    el.on(\"remove\", function(){\n",
       "\tfig.close_ws(fig, {});\n",
       "    });\n",
       "}\n",
       "\n",
       "mpl.figure.prototype._canvas_extra_style = function(el){\n",
       "    // this is important to make the div 'focusable\n",
       "    el.attr('tabindex', 0)\n",
       "    // reach out to IPython and tell the keyboard manager to turn it's self\n",
       "    // off when our div gets focus\n",
       "\n",
       "    // location in version 3\n",
       "    if (IPython.notebook.keyboard_manager) {\n",
       "        IPython.notebook.keyboard_manager.register_events(el);\n",
       "    }\n",
       "    else {\n",
       "        // location in version 2\n",
       "        IPython.keyboard_manager.register_events(el);\n",
       "    }\n",
       "\n",
       "}\n",
       "\n",
       "mpl.figure.prototype._key_event_extra = function(event, name) {\n",
       "    var manager = IPython.notebook.keyboard_manager;\n",
       "    if (!manager)\n",
       "        manager = IPython.keyboard_manager;\n",
       "\n",
       "    // Check for shift+enter\n",
       "    if (event.shiftKey && event.which == 13) {\n",
       "        this.canvas_div.blur();\n",
       "        event.shiftKey = false;\n",
       "        // Send a \"J\" for go to next cell\n",
       "        event.which = 74;\n",
       "        event.keyCode = 74;\n",
       "        manager.command_mode();\n",
       "        manager.handle_keydown(event);\n",
       "    }\n",
       "}\n",
       "\n",
       "mpl.figure.prototype.handle_save = function(fig, msg) {\n",
       "    fig.ondownload(fig, null);\n",
       "}\n",
       "\n",
       "\n",
       "mpl.find_output_cell = function(html_output) {\n",
       "    // Return the cell and output element which can be found *uniquely* in the notebook.\n",
       "    // Note - this is a bit hacky, but it is done because the \"notebook_saving.Notebook\"\n",
       "    // IPython event is triggered only after the cells have been serialised, which for\n",
       "    // our purposes (turning an active figure into a static one), is too late.\n",
       "    var cells = IPython.notebook.get_cells();\n",
       "    var ncells = cells.length;\n",
       "    for (var i=0; i<ncells; i++) {\n",
       "        var cell = cells[i];\n",
       "        if (cell.cell_type === 'code'){\n",
       "            for (var j=0; j<cell.output_area.outputs.length; j++) {\n",
       "                var data = cell.output_area.outputs[j];\n",
       "                if (data.data) {\n",
       "                    // IPython >= 3 moved mimebundle to data attribute of output\n",
       "                    data = data.data;\n",
       "                }\n",
       "                if (data['text/html'] == html_output) {\n",
       "                    return [cell, data, j];\n",
       "                }\n",
       "            }\n",
       "        }\n",
       "    }\n",
       "}\n",
       "\n",
       "// Register the function which deals with the matplotlib target/channel.\n",
       "// The kernel may be null if the page has been refreshed.\n",
       "if (IPython.notebook.kernel != null) {\n",
       "    IPython.notebook.kernel.comm_manager.register_target('matplotlib', mpl.mpl_figure_comm);\n",
       "}\n"
      ],
      "text/plain": [
       "<IPython.core.display.Javascript object>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "data": {
      "text/html": [
       "<img src=\"data:image/png;base64,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\" width=\"833\">"
      ],
      "text/plain": [
       "<IPython.core.display.HTML object>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "# I will modify the code from the scipython.com forest fire model\n",
    "#to represent my percolation model\n",
    "\n",
    "%matplotlib notebook\n",
    "\n",
    "\n",
    "EMPTY,ROCK,WATER = 0, 1, 2\n",
    "# Colours for visualization: brown for ROCK, white for EMPTY and blue\n",
    "# for WATER. Note that for the colormap to work, this list and the bounds list\n",
    "# must be one larger than the number of different values in the array.\n",
    "\n",
    "#I initially chose shades of brown for water accepting and water blocking soil, however those\n",
    "#colors were less easily separated visually\n",
    "\n",
    "\n",
    "\n",
    "source= 0 #1,2,3,4\n",
    "\n",
    "#Source 0 is above\n",
    "#Source 1 the left\n",
    "#Source 2 is beneath\n",
    "#Source 3 is the right\n",
    "#Source 4 is the center\n",
    "\n",
    "\n",
    "\n",
    "colors_list = ['gray', 'brown','blue']\n",
    "cmap = colors.ListedColormap(colors_list)\n",
    "bounds = [0,1,2,3]\n",
    "norm = colors.BoundaryNorm(bounds, cmap.N)\n",
    "\n",
    "def iterate(X):\n",
    "    \"\"\"Iterate the ground according to the percolation rules.\"\"\"\n",
    "\n",
    "\n",
    "    \n",
    "    # In this model we will only count the four nearest neighbors, above, below, left, and right\n",
    "    # this assumes that water cannot move between the crack of two rock neighbors \n",
    "    neighborhood = ((-1,0), (0,-1), (0, 1), (1,0))\n",
    "    X1 = np.zeros((ny, nx))\n",
    "    \n",
    "    # The boundary of the ground is always empty, so only consider cells\n",
    "    # indexed from 1 to nx-2, 1 to ny-2\n",
    "    \n",
    "    for ix in range(1,nx-1):\n",
    "        for iy in range(1,ny-1):\n",
    "            \n",
    "            #if the cell is rock or water or empty before it will stay the same\n",
    "            if X[iy,ix] == WATER: \n",
    "                X1[iy,ix] = WATER\n",
    "            if X[iy,ix] == ROCK: \n",
    "                X1[iy,ix] = ROCK\n",
    "            if X[iy,ix] == EMPTY:\n",
    "                X1[iy,ix] = EMPTY\n",
    "                        #unless the cell is empty next to water\n",
    "                        #in which case it will become a water cell\n",
    "                for dx,dy in neighborhood:\n",
    "                    if X[iy+dy,ix+dx] == WATER:\n",
    "                        X1[iy,ix] = WATER\n",
    "                        break\n",
    "    return X1\n",
    "\n",
    "# The initial fraction of the forest occupied by rocks.\n",
    "rock_fraction = 0.30\n",
    "\n",
    "# ground section size (number of cells in x and y directions).\n",
    "nx, ny = 50, 50\n",
    "\n",
    "\n",
    "# Initialize the ground section grid.\n",
    "X  = np.zeros((ny, nx))\n",
    "\n",
    "X[1:ny-1, 1:nx-1] = np.random.randint(0, 2, size=(ny-2, nx-2))\n",
    "\n",
    "#initializes the rocks\n",
    "X[1:ny-1, 1:nx-1] = np.random.random(size=(ny-2, nx-2)) < rock_fraction\n",
    "\n",
    "if source == 0: #above\n",
    "    X[0,0:nx-1] = 2\n",
    "    \n",
    "if source == 1: #left\n",
    "    X[0:ny-1,0] = 2\n",
    "    \n",
    "if source == 2: #beneath\n",
    "    X[0:ny-1,0] = 2\n",
    "    \n",
    "if source == 3: #right\n",
    "    X[0:ny-1,ny-1] = 2\n",
    "    \n",
    "if source == 4: #center\n",
    "    midy= ny//2\n",
    "    midx= nx//2\n",
    "    X[midy,midx] = 2\n",
    "\n",
    "fig = plt.figure(figsize=(25/3, 6.25))\n",
    "ax = fig.add_subplot(111)\n",
    "ax.set_axis_off()\n",
    "im = ax.imshow(X, cmap=cmap, )#norm=norm)#, interpolation='nearest')\n",
    "\n",
    "# The animation function: called to produce a frame for each generation.\n",
    "def animate(i):\n",
    "    im.set_data(animate.X)\n",
    "    animate.X = iterate(animate.X)\n",
    "# Bind our grid to the identifier X in the animate function's namespace.\n",
    "animate.X = X\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "# Interval between frames (ms).\n",
    "interval = 100\n",
    "anim = animation.FuncAnimation(fig, animate, interval=interval,frames=150,repeat=False,save_count=150)\n",
    "#anim.save('test.mp4')\n",
    "\n",
    "#mywriter = animation.FFMpegWriter()\n",
    "#anim.save('mymovie.mp4',writer=mywriter)\n",
    "plt.show()\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Data + Fruitful function\n",
    "\n",
    "The function below unlike the function above\n",
    "* cannot make animations (yet)\n",
    "* is fruitful and returns data"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "metadata": {},
   "outputs": [],
   "source": [
    "def percolate_sim(width,height,rock_fraction,percent_return=False,source=0):\n",
    "    \"\"\"This function simulates the percolation of groundwater through porous soil. \n",
    "    This simulation does not take gravity into account, and assumes that the \n",
    "    water source is at sufficient pressure that if an available square is next to the water\n",
    "    the water will fill it.\n",
    "    \n",
    "    Code is based off/inspired by:\n",
    "    https://scipython.com/blog/the-forest-fire-model/\n",
    "    \n",
    "    \n",
    "    parameters:\n",
    "    (width,height): tuple of integers representing the width and height of the soil section \n",
    "    respectively\n",
    "    rock_fraction: float <1 that represents the percentage of rock in the soil which cannot\n",
    "    absorb water\n",
    "    data_return: boolean which when true returns the initial conditions in an nx by \n",
    "    ny matrix, as well as the percentage of empty sections filled with water\n",
    "    source: integer between 0 and 4, correspoding to different water source loactions\n",
    "    which correspond respectively to above left, below, right, and center.\n",
    "    \n",
    "    \n",
    "    \n",
    "    returns(optional, see percent_return flag)\n",
    "    X_start: (ny*nx, 1) of initial conditions(0 = empty, 1 = rock, 2 = water)\n",
    "    perc_vector: 1*2 numpy array\n",
    "    percentage submerged: float between 0 and 1, rounded to the nearest .1 for analysis \n",
    "    purposes\n",
    "    \n",
    "    \"\"\"\n",
    "    %matplotlib notebook\n",
    "    #so any animation will be generated in the notebook\n",
    "    \n",
    "    EMPTY,ROCK,WATER = 0, 1, 2\n",
    "    # Colours for visualization: brown for ROCK, gray for EMPTY and blue\n",
    "    # for WATER. \n",
    "    \n",
    "    #sets up colormap\n",
    "    colors_list = ['gray', 'brown','blue']\n",
    "    cmap = colors.ListedColormap(colors_list)\n",
    "    bounds = [0,1,2,3]\n",
    "    norm = colors.BoundaryNorm(bounds, cmap.N)\n",
    "    \n",
    "    nx =width\n",
    "    ny= height\n",
    "    \n",
    "    # Initialize the ground section grid.\n",
    "    X  = np.zeros((ny, nx))\n",
    "    \n",
    "    #initializes the rocks\n",
    "    X[1:ny-1, 1:nx-1] = np.random.randint(0, 2, size=(ny-2, nx-2))\n",
    "    X[1:ny-1, 1:nx-1] = np.random.random(size=(ny-2, nx-2)) < rock_fraction\n",
    "    \n",
    "    #Source 0 is above\n",
    "    #Source 1 the left\n",
    "    #Source 2 is beneath\n",
    "    #Source 3 is the right\n",
    "    #Source 4 is the center\n",
    "\n",
    "    if source == 0: #above\n",
    "        X[0,0:nx-1] = 2\n",
    "    \n",
    "    if source == 1: #left\n",
    "        X[0:ny-1,0] = 2\n",
    "    \n",
    "    if source == 2: #beneath\n",
    "        X[0:ny-1,0] = 2\n",
    "    \n",
    "    if source == 3: #right\n",
    "        X[0:ny-1,ny-1] = 2\n",
    "    \n",
    "    if source == 4: #center\n",
    "        midy= ny//2\n",
    "        midx= nx//2\n",
    "        X[midy,midx] = 2\n",
    "        \n",
    "    X_start = X\n",
    "    #saves the initial conditions\n",
    "    \n",
    "    #-----------------------------------------------------------------------------#\n",
    "    #creates the figure\n",
    "    #fig = plt.figure(figsize=(25/3, 6.25))\n",
    "    #ax = fig.add_subplot(111)\n",
    "    #ax.set_axis_off()\n",
    "    #im = ax.imshow(X, cmap=cmap, )#norm=norm)#, interpolation='nearest')\n",
    "        \n",
    "    #animate.X=X\n",
    "    #if x is referenced, it is x animated\n",
    "    \n",
    "    # Interval between frames (ms).\n",
    "    #interval = 100\n",
    "    #anim = animation.FuncAnimation(fig, animate, interval=interval)#,frames=200)\n",
    "    #plt.show()\n",
    "    #-----------------------------------------------------------------------------#\n",
    "    \n",
    "    #okay so now I will just create the data returns while I have not yet gotten the animation\n",
    "    #to work in the subroutine.\n",
    "    \n",
    "    for i in range(200):\n",
    "        X= iterate(X)\n",
    "        #iterates x 200 times\n",
    "        \n",
    "    \n",
    "    if percent_return:\n",
    "        #now to find the percentage submerged\n",
    "        final_data = np.reshape(X, (nx*ny, 1))\n",
    "        \n",
    "\n",
    "        #removing the rocks from the data\n",
    "        np.delete(final_data, np.where(final_data == 1), axis=0)\n",
    "\n",
    "        #average remaining values\n",
    "        almost_percentage=np.mean(final_data)\n",
    "        percentage= almost_percentage/2 #since water is worth 2 not 1\n",
    "\n",
    "        percentage= round(percentage,1) #rounds to the nearest percentage\n",
    "\n",
    "\n",
    "        return X_start,percentage \n",
    "    else:\n",
    "        final_data=X\n",
    "        if source == 0: #above\n",
    "            check_area = final_data[ny-2:,:]#if the water has made it within 3 cells of the\n",
    "                #other side\n",
    "            #print(check_area.shape)\n",
    "        elif source == 1: #left\n",
    "            check_area = final_data[:,:2]\n",
    "        elif source == 2: #beneath\n",
    "            check_area = final_data[:2,:]\n",
    "        elif source == 3: #right\n",
    "            check_area=final_data[:,nx-2:]\n",
    "        elif source == 4:\n",
    "            final_data[2:ny-2,2:nx-2]=0 #removes all but boarders\n",
    "            check_area = final_data\n",
    "        else: \n",
    "            print(\"other sources not working currently\")\n",
    "        #checks for percolation\n",
    "        perc_vector = np.zeros((2,1))\n",
    "        if 2 in check_area:\n",
    "            perc_vector[1]=1 #0% unpercolated and 100% percolated\n",
    "            #[0,1]\n",
    "        else:\n",
    "            perc_vector[0]=1 #100% unpercolated and 0% percolated\n",
    "            #[1,0]\n",
    "        #changed to vector instead of boolean\n",
    "        #to have two nodes on final layer instead of just one\n",
    "        \n",
    "            \n",
    "    #I still need as a list for the network!        \n",
    "    X_start_layer=np.reshape(X_start, (nx*ny, 1))\n",
    "\n",
    "    return X_start_layer, perc_vector\n",
    "    "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 19,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[[1.]\n",
      " [0.]]\n"
     ]
    }
   ],
   "source": [
    "# this is a test to make sure that we are getting the expected value from the function\n",
    "\n",
    "values = percolate_sim(100,100,.2,percent_return=False,source=0)\n",
    "print(values[1])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 22,
   "metadata": {},
   "outputs": [],
   "source": [
    "number_of_samples=10 #set sample number\n",
    "all_rocks=[.1,.2,.3,.4,.5,.6,.7,.8,.9]\n",
    "extreme_rocks=[.9,.8,.1,.2]\n",
    "critical_rocks=[.3,.4,.5,.6]\n",
    "#types of rock fraction lists, change to your purpose\n",
    "\n",
    "\n",
    "training_set = []\n",
    "for i in range (number_of_samples):\n",
    "    #print(i)\n",
    "    rocks=random.choice(extreme_rocks) #extreme data\n",
    "    training_set.append(percolate_sim(50,50,rocks,percent_return=False,source=0))\n",
    "    \n",
    "testing_set=[]\n",
    "for i in range (number_of_samples):\n",
    "    #print(i)\n",
    "    rocks=random.choice(critical_rocks) #data near critical point\n",
    "    testing_set.append(percolate_sim(50,50,rocks,percent_return=False,source=0))\n",
    "\n",
    "\n",
    "\n",
    "    \n",
    "    \n",
    "    \n",
    "#np.save('training.npy', training_set)\n",
    "#np.save('testing.npy', testing_set)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.4"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
